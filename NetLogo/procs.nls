
to setup
  clear-all
  set proposed-chain []
  set overall-block 0
  set_constants
  setup_peers
  reset-ticks ;; start the clock
  set-plots
  initiate_round
end

to set-plots
  set-plot-x-range -1 No-of-Peers
  set-plot-y-range 0 100
end


to set_constants
  set no-of-votes-required ceiling( No-of-Peers  * ( Votes-Required / 100 ) )
  set-default-shape peers "a_peer"
  ;; Constant setup
  set subdue-color 4
  set current-round 0
  set current-block-proposer-id ""
  ;; Timing setup (TODO: Move to UI if necessary)
  set peer-breathe-time 2
end

to scheduled-events
  if ticks mod Block-Timeout = 0 [ initiate_block ]
  ask peers [
    if ticks mod con-strength = 0 [ push-peer-block ]
  ]
end

to go
  if current-round > Rounds + 1 [ stop ] ;; Stopping forever button
  tick
  scheduled-events
end

to-report current-round-no
  report current-round
end

to-report current-block-no
  report current-block
end

to-report attack_tolerance_data ;; Possibility of protection being enough for the block to be voted in 
  ;; report (No-of-Peers - no-of-votes-required ) >= count peers with [is-down]
  report (word count peers with [is-down] "/" (No-of-Peers - no-of-votes-required ) )
end

to setup_peers
  ;; Creating Servers
  create-servers 1 [
    set color blue
    set shape "a_server"
    setxy -15 0
  ]
  create-attackers 1 [
    set color orange
    set shape "monster"
    setxy 15 0
  ]
  set bserver one-of servers
  set battacker one-of attackers
  ;; Creating Peers
  create-peers No-of-Peers [
    ;; set color turquoise
    setxy random-pxcor random-pycor
    set peer-id (word "p_" who)
    set block ""
    set block-voters []
    set chain []
    set is-protected False
    set is-down False
    set con-strength Min-Con-Strength +  random (Max-Con-Strength - Min-Con-Strength)
    set allowed-link-no Min-Peer-Cons + random (Max-Peer-Cons - Min-Peer-Cons)
  ]
  ask bserver [
    create-server-cons-to other peers [
      set color blue - subdue-color
      set delay [con-strength] of other-end
    ]
    ;; ask my-out-server-cons []
  ]
  ask battacker [
    create-attacker-cons-to other peers [
      set delay [con-strength] of other-end
      set color orange - subdue-color
    ]
  ]
  ask peers [
    let available-links [allowed-link-no] of self - (count my-peer-cons ) ;; leftover links than the default server/attacker connections
    if available-links > 0 [
      create-peer-cons-with n-of available-links other peers
    ]
    ask peer-cons [
      set color turquoise
      set delay min(list [con-strength] of end1 [con-strength] of end2)
      ;; set thickness delay /(last const-con-strength * 10) ;; TODO: Uncomment for visual confirmation
    ]
  ]
end

to initiate_round
  set current-round (current-round + 1)
  if current-round > Rounds + 1 [
    console-log("Round number reached. Simulation will stop soon.")
    stop
  ]
  set current-block 0
  remove_attacker_influence
  ask peers [ set-peer-protection-decision ]  
  ask battacker [ set-list-of-blocks-to-attack  ]
end

to plot-vote-precentage
  let obtained-votes-no count peers with [not empty? chain and first last chain = last proposed-chain] ;; first element (block string) of last item in chain = last element in proposed-chain 
  plotxy overall-block ( ( obtained-votes-no / No-of-Peers ) * 100 )
end

to initiate_block
  if overall-block > 0 [  
    ask peers [ finalize-proposed-block ]
    console-log(word "Finished: Round: " current-round " Block: " current-block " Attack Tolerance: " attack_tolerance_data)
    update-plots
    plot-vote-precentage 
  ]
  if (current-block + 1) > No-of-Peers [
    initiate_round
    stop
  ]
  set current-block (current-block + 1)
  set overall-block (overall-block + 1)
  console-log(word "Started: Round: " current-round " Block: " current-block)
  remove_attacker_influence
  if member? current-block [blocks-to-attack] of battacker [
    ask battacker [
      ask attacker-con-neighbors [ attack_agent ]
    ]
  ]
  ask one-of peers with  [not is-down and peer-id != current-block-proposer-id ] [ ;; ask new proposer
    set current-block-proposer-id peer-id
    set current-block-start-time ticks
    set block (word "b_" overall-block "_" current-block-proposer-id)
    set proposed-chain lput block proposed-chain
    add-block-vote current-block-proposer-id
    push-peer-block
  ]
end

to receive-block [proposed-block voter-list]
  if is-down [ stop ]
  if empty? proposed-block or empty? voter-list [ stop ]
  if empty? block [
    set block proposed-block
  ]
  set block-voters sentence block-voters voter-list
  set block-voters remove-duplicates block-voters
  if not empty? block and proposed-block = block [
    add-block-vote peer-id
  ]
  ;; console-log(word "Received " block " " voter-list)
end


to push-peer-block ;; turtle-method
  if empty? block or is-down [ stop ]
  let proposed-block block
  let voter-list block-voters
  ask out-peer-con-neighbors [
    receive-block proposed-block voter-list
  ]
end

to finalize-proposed-block ;; turtle-method
  if is-down [stop]
  if length block-voters > no-of-votes-required [
    set chain lput (list block block-voters) chain 
  ]
  set block ""
  set block-voters []
end

to remove_attacker_influence
  ask peers [
    if not is-down [ stop ]
    set is-down False
    set shape "a_peer"
  ]
end

to attack_agent
  if not is-protected [
    set is-down True
    set shape "a_victim"
  ] 
end

;; Below items are TODO

to set-peer-protection-decision 
  set is-protected one-of [ true false ]  ;; TODO 
end


