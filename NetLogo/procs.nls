
to setup
  clear-all
  py:setup py:python
  py:run "import autarki_agent as pyagent"
  set_run
  set_constants
  setup_peers
  ;; setup_gossip_transactions ;; (NOTE: Used for gossip transaction propogation over direct transmission)
  reset-ticks ;; start the clock
  set-plots
end

to set-plots
  set-plot-x-range -1 No-of-Peers
  set-plot-y-range 0 100
end

to set_run
  py:set "run_no" behaviorspace-run-number
  py:set "run_name" behaviorspace-experiment-name
  py:set "total_peers" No-of-Peers
  py:set "required_votes" Votes-Required ;; Percentage Conversion done inside python
  py:set "timeout_in_seconds" Block-Timeout
  py:set "learning_strategy" Learning-Methodology
  py:set "is_cost_heterogeneous" Heterogeneous-Cost
  py:set "benefit_per_unit_of_cost" Benefit-Per-Unit-Of-Cost
  py:set "minimum_attack_probability" Min-Attack-Probability
  py:set "desc_data" (list Duration Min-Con-Strength Max-Con-Strength Min-Peer-Cons Max-Peer-Cons)
  py:run "pyagent.init_run(run_no, run_name, total_peers, required_votes, learning_strategy, is_cost_heterogeneous, benefit_per_unit_of_cost, minimum_attack_probability, desc_data)"
end

to set_constants
  set-default-shape peers "a_peer"
  ;; Constant setup
  set subdue-color 4
  set current-round 0
  set current-block-proposer-id ""
  ;; Timing setup (TODO: Move to UI if necessary)
  set new-transaction-generation-time 10 ;; TODO Increase if transaction propagation is used
  set peer-breathe-time 2
end

to go
  initiate_round
  time:go-until Duration;; (TODO: substitute ticks with number of rounds when termination is deterministic)
  ;; py:run "pyagent.log_agent_chains(run_no)"
  ;; ask peers [ console-log(list who transactions) ] ;; TODO
end

to-report current-round-no
  report current-round
end

to-report current-block-no
  report current-block
end

to-report overall-block
  report ( (current-round - 1)* No-of-Peers ) + current-block
end

to-report attack_tolerance_data
  let no-of-attackers-tolerable (py:runresult "pyagent.get_no_of_attackers_tolerable(run_no)")
  report (word count peers with [is-down] "/" no-of-attackers-tolerable)
end

to setup_peers
  ;; Creating Servers
  create-servers 1 [
    set color blue
    set shape "a_server"
    setxy -15 0
  ]
  create-attackers 1 [
    set color orange
    set shape "monster"
    setxy 15 0
  ]
  set bserver one-of servers
  set battacker one-of attackers
  ;; Creating Peers
  create-peers No-of-Peers [
    ;; set color turquoise
    setxy random-pxcor random-pycor
    set transactions "{}"
    set block "{}"
    set is-down False
    set con-strength Min-Con-Strength +  random (Max-Con-Strength - Min-Con-Strength)
    set allowed-link-no Min-Peer-Cons + random (Max-Peer-Cons - Min-Peer-Cons)
    py:set "x" who ;; TONOTE: This is for record keeping/signature. Peers will not be addressed through this.
    set peer-id (py:runresult "pyagent.create_peer(run_no, x)")
  ]
  ask bserver [
    create-server-cons-to other peers [
      set color blue - subdue-color
      set delay [con-strength] of other-end
    ]
    ;; ask my-out-server-cons []
  ]
  ask battacker [
    create-attacker-cons-to other peers [
      set delay [con-strength] of other-end
      set color orange - subdue-color
    ]
  ]
  ask peers [
    let available-links [allowed-link-no] of self - (count my-peer-cons ) ;; leftover links than the default server/attacker connections
    if available-links > 0 [
      create-peer-cons-with n-of available-links other peers
    ]
    ask peer-cons [
      set color turquoise
      set delay min(list [con-strength] of end1 [con-strength] of end2)
      ;; set thickness delay /(last const-con-strength * 10) ;; TODO: Uncomment for visual confirmation
    ]
  ]
  py:set "peers_list" [peer-id] of peers
  py:run "pyagent.set_peer_network_variables(run_no, peers_list)"
end

to initiate_round
  carefully [
  set current-round (current-round + 1)
  py:set "current_round" current-round
  set current-block 0
  remove_attacker_influence
  py:run "pyagent.start_round(run_no, current_round)"
  ask battacker [ set blocks-to-attack (py:runresult "pyagent.get_blocks_to_attack(run_no, current_round)")  ]
  ;; TODO bring forward remaining transactions if any (Check Readme)
  reschedule_events 10 ;; Start after at least 10 transactions
  ]
  [ console-log("ERROR: Round initiations ") ]
end

to reschedule_events [block_count]
  time:clear-schedule
  schedule_transaction_propagation_temp ;; TODO change for realistic simulation
  schedule_block block_count ;; Start after at least 10 transactions
  ;; ask peers [ time:schedule-repeating-event self [ [] -> push-peer-block ] ticks (con-strength) ] ;; TODO (Not suitable)
end

to schedule_block [tail]
    let new-time (ticks + (new-transaction-generation-time * tail))
    time:schedule-event "observer" [ [] -> initiate_block ] new-time  ;; Start after at least `tail` transactions
end

to plot-vote-precentage
  py:set "current_block" block
  let obtained-votes-no (py:runresult "pyagent.get_no_of_votes(current_block)")
  let obtained-vote-precentage ( ( obtained-votes-no / No-of-Peers ) * 100 )
  plotxy overall-block obtained-vote-precentage
end

to initiate_block
  ask peers with [peer-id = current-block-proposer-id ] [
    console-log(word "Finished: Round: " current-round " Block: " current-block " Attack Tolerance: " attack_tolerance_data)
    carefully [ 
      update-plots
      plot-vote-precentage
    ] [ console-log("ERROR: Plotting error") ]
  ]
  if (current-block + 1) > No-of-Peers [
    initiate_round
    stop
  ]
  set current-block (current-block + 1)
  console-log(word "Started: Round: " current-round " Block: " current-block)
  remove_attacker_influence
  if member? current-block [blocks-to-attack] of battacker [
    ask battacker [
      ask attacker-con-neighbors [ attack_agent ]
    ]
  ]
  carefully [ set current-block-proposer-id get_proposer ] [ console-log("ERROR: Proposer error") ]
  py:set "curr_proposer_id" current-block-proposer-id
  py:set "curr_time" ticks
  set current-block-start-time ticks
  ask peers with [peer-id = current-block-proposer-id ] [
    set block (py:runresult "pyagent.get_new_block(run_no, curr_proposer_id, curr_time)")
    carefully [push-peer-block] [console-log("ERROR : Initial block push")]
  ]
end

to receive-block [proposed-block sending-peer recurse]
  if is-down [stop]
  let tmp_ticks ticks
  let is-block-timeout (tmp_ticks  > (current-block-start-time + Block-Timeout) ) 
  if is-block-timeout [
    reschedule_events 5
    stop
  ]  
  py:set "p_id" [peer-id] of self
  let temp-returned (py:runresult "pyagent.propagate_block_to_peer(run_no, p_id, proposed_block)")
  let was-processed first temp-returned
  let process-returns last temp-returned
  if not was-processed [
    ifelse process-returns != "" and recurse [
      request-blockchain first process-returns last process-returns
      receive-block proposed-block sending-peer false ;; Fix for infinite loop
    ]
    [
      console-log(word "Empty Block " [peer-id] of self) ;; TODO exit here? Priority #2
      stop
    ]
  ]
  if was-processed [
    let was-accepted first process-returns
    let temp-block last process-returns
    py:set "curr_proposer_id" current-block-proposer-id
    if temp-block != "" [
      set block temp-block
      ;; py:run "pyagent.notify_proposer(run_no, curr_proposer_id, p_id)" ;; For termination purposes. This could be done via python itself but we add here for realistic purposes
      time:schedule-event self [ [] -> push-peer-block ] (tmp_ticks + con-strength) ;; TODO This is problematic
    ]
    if was-accepted and recurse [ ;; fix for infinite loop
      carefully [push-peer-block-to-all] [console-log("ERROR : Final Block Push")]
    ]
  ]
end


to push-peer-block ;; turtle-method
  if block = "{}" or block = "" or is-down [ stop ]
  py:set "proposed_block" block
    py:set "sending_peer" current-block-proposer-id ;; [peer-id] of self ;; For request-blockchain method
    ask out-peer-con-neighbors [
      receive-block block ([peer-id] of self) true
    ]
end

to push-peer-block-to-all ;; turtle-method
  py:set "proposed_block" block
  py:set "sending_peer" [peer-id] of self ;; For request-blockchain method
  ask peers [
    receive-block block ([peer-id] of self) false
  ]
  ask peers with [peer-id = current-block-proposer-id ] [
    let block_in_chain (py:runresult "pyagent.check_proposed_block_status(run_no, curr_proposer_id)")
    ;; if block_in_chain [
      reschedule_events 5 ;; But one block must success or this loops forever TODO
    ;;]
  ]
end

to request-blockchain [from_index to_index] ;; turtle-method
  console-log("Blockchain Request")
  py:set "update_index_to" to_index
  py:set "update_index_from" from_index
  let transfer-success (py:runresult "pyagent.blockchain_request(run_no, p_id, sending_peer, update_index_from, update_index_to)") ;; TODO Change to most available peer if necessary
  if not transfer-success [
    console-log(word "Blockchain transfer successful :" transfer-success)
  ]
end

to remove_attacker_influence
  ask peers [
    if not is-down [ stop ]
    py:set "p_id" [peer-id] of self
    py:run "pyagent.remove_attacker_influence(run_no, p_id)"
    set is-down False
    set shape "a_peer"
  ]
end

to-report get_proposer
  py:set "prev_proposer_id" current-block-proposer-id
  let candidate ""
  while [candidate = ""] [
    set candidate (py:runresult "pyagent.get_proposer(run_no, prev_proposer_id)")
    ask peers with [peer-id = candidate] [
      if is-down [ set candidate "" ]
    ]
  ]
  py:set "curr_proposer_id" candidate
  py:run "pyagent.complete_proposer_transfer(run_no, prev_proposer_id, curr_proposer_id)"
  report candidate
end

to attack_agent
  py:set "p_id" [peer-id] of self
  set is-down (py:runresult "pyagent.attack_agent(run_no, p_id)")
  if not is-down [ stop ]
  set shape "a_victim"
  ;; ask my-peer-cons [ set color red ] ;; TONOTE: Not necessary since incoming would still work (and be wasted cuz agent is down)
end
