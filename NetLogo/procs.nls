
to setup
  clear-all
  py:setup py:python
  py:run "import autarki_agent as pyagent"
  py:set "run_no" behaviorspace-run-number
  py:run "pyagent.init_run(run_no)"
  ;; ask patches [ set pcolor white ]
  set_constants
  setup_peers
  reset-ticks ;; start the clock
  initiate_round
end

to go
  time:go-until Duration;; (ticks)
  output-print(word "Current Round - " current-round)
  output-print(word "Current Block - " current-block)
  ;; py:run "pyagent.log_agent_chains(run_no)"
  ;; ask peers [ output-print(list who transactions) ] ;; TODO
end

to set_constants
  set-default-shape peers "a_peer"
  ;; Constant setup
  set subdue-color 4
  set current-round 0
  set current-block-proposer-id ""
  ;; Network setup
  set first-contact round (No-of-Peers / 10) ;; TODO Move to UI
  set const-con-strength (list 1 10) ;; TODO Move to UI
  set const-peers (list 2 4)  ;; TODO Move to UI
  set const-attack-probabilities (list 0.01 1) ;; TODO Move to UI (only Minimum attack probability)
  ;; Timing setup
  set new-transaction-generation-time 10 ;; TODO Increase if transaction propagation is used
  py:set "timeout_in_seconds" Block-Timeout
  py:run "pyagent.set_block_timeout(run_no, timeout_in_seconds)"
  set peer-breathe-time 2
end

to setup_peers
  ;; Creating Servers
  create-servers 1 [
    set color blue
    set shape "a_server"
    setxy -15 0
  ]
  create-attackers 1 [
    set color orange
    set shape "monster"
    setxy 15 0
  ]
  set bserver one-of servers
  set battacker one-of attackers
  ;; Creating Peers
  create-peers No-of-Peers [
    ;; set color turquoise
    setxy random-pxcor random-pycor
    set transactions "{}"
    set block "{}"
    set is-down False
    set con-strength first const-con-strength +  random (last const-con-strength - first const-con-strength)
    set allowed-link-no first const-peers + random (last const-peers - first const-peers) 
    py:set "x" who ;; TONOTE: This is for record keeping/signature. Peers will not be addressed through this. 
    set peer-id (py:runresult "pyagent.create_peer(run_no, x)")
  ]
  ask bserver [ 
    create-server-cons-to other peers [ 
      set color blue - subdue-color  
      set delay [con-strength] of other-end 
    ]
    ;; ask my-out-server-cons []
  ]
  ask battacker [ 
    create-attacker-cons-to other peers [ 
      set delay [con-strength] of other-end
      set color orange - subdue-color
    ]
  ]
  ask peers [
    let available-links [allowed-link-no] of self - (count my-peer-cons ) ;; leftover links than the default server/attacker connections
    if available-links > 0 [ 
      create-peer-cons-with n-of available-links other peers
    ]
    ask peer-cons [
      set color turquoise
      set delay min(list [con-strength] of end1 [con-strength] of end2)
      ;; set thickness delay /(last const-con-strength * 10) ;; TODO: Uncomment for visual confirmation
    ]   
  ]
  py:set "peers_list" [peer-id] of peers
  py:set "required_votes" Votes-Required ;; Percentage Conversion done inside python
  py:run "pyagent.set_peer_network_variables(run_no, peers_list, required_votes)"
end

to initiate_round
  set current-round (current-round + 1)
  py:set "current_round" current-round
  set current-block 0
  remove_attacker_influence
  py:set "attack_probability_range" const-attack-probabilities
  py:set "blocks_to_be_proposed" No-of-Peers
  py:run "pyagent.start_round(run_no, current_round, blocks_to_be_proposed, attack_probability_range)"
  ask battacker [ set blocks-to-attack (py:runresult "pyagent.get_blocks_to_attack(run_no, current_round)")  ]
  ;; TODO bring forward remaining transactions if any (Check Readme)
  reschedule_events 10 ;; Start after at least 10 transactions 
end

to reschedule_events [block_count]
  time:clear-schedule
  schedule_transaction_propagation_temp ;; TODO change for realistic simulation
  schedule_block block_count ;; Start after at least 10 transactions
  ;; ask peers [ time:schedule-repeating-event self [ [] -> push-peer-block ] ticks (con-strength) ] ;; TODO (Not suitable)
end

to schedule_block [tail]
    let new-time (ticks + (new-transaction-generation-time * tail))
    time:schedule-event "observer" [ [] -> initiate_block ] new-time  ;; Start after at least `tail` transactions
end

to initiate_block
  set current-block (current-block + 1)
  output-print(word "Round: " current-round " Block: " current-block)
  if current-block > No-of-Peers [
    initiate_round
    stop
  ]
  remove_attacker_influence
  if member? current-block [blocks-to-attack] of battacker [
    ask battacker [
      ask attacker-con-neighbors [ attack_agent ]
    ]
  ]
  set current-block-proposer-id get_proposer
  py:set "curr_proposer_id" current-block-proposer-id
  py:set "curr_time" ticks
  output-print(word "start_block " ticks)
  ask peers with [peer-id = current-block-proposer-id ] [
    set block (py:runresult "pyagent.get_new_block(run_no, curr_proposer_id, curr_time)")
    push-peer-block
  ]
end

to receive-block [proposed-block sending-peer]
  if is-down [stop]
  let is-block-timeout (py:runresult "pyagent.if_block_timed_out(run_no)")
  if is-block-timeout [
    reschedule_events 5
    stop
  ]
  let tmp_ticks ticks
  py:set "p_id" [peer-id] of self
  let temp-returned (py:runresult "pyagent.propagate_block_to_peer(run_no, p_id, proposed_block)")
  let was-processed first temp-returned
  let process-returns last temp-returned
  if not was-processed [
    ifelse process-returns != "" [
      request-blockchain first process-returns last process-returns
      ;; receive-block proposed-block sending-peer ;; TODO Fix possible infinite loop and index out of range issue
    ]
    [
      output-print(word "Empty Block" [peer-id] of self) ;; TODO exit here? Priority #2 
      stop
    ]
  ]
  if was-processed [
    let was-accepted first process-returns
    let temp-block last process-returns
    py:set "curr_proposer_id" current-block-proposer-id
    if temp-block != "" [
      set block temp-block
      py:run "pyagent.notify_proposer(run_no, curr_proposer_id, p_id)" ;; For termination purposes. This could be done via python itself but we add here for realistic purposes
      time:schedule-event self [ [] -> push-peer-block ] (tmp_ticks + con-strength) ;; TODO This is problematic
    ]
    if was-accepted and (current-block-proposer-id = peer-id) [
      ;; Note: For simulation (early) round termination purposes. Not an implementation of Blockchain (Votes <> Block is added enough times)
      let block_in_chain (py:runresult "pyagent.check_proposed_block_status(run_no, curr_proposer_id)")
      if block_in_chain [
        reschedule_events 5
      ]
    ]
  ]
end

to push-peer-block ;; turtle-method
  if block != "{}" and not is-down  [
    py:set "proposed_block" block
    py:set "sending_peer" [peer-id] of self ;; For request-blockchain method
    ask out-peer-con-neighbors [
      receive-block block [peer-id] of self
    ]
  ]
end

to request-blockchain [from_index to_index] ;; turtle-method
  py:set "update_index_to" to_index
  py:set "update_index_from" from_index
  let transfer-success (py:runresult "pyagent.blockchain_request(run_no, p_id, sending_peer, update_index_from, update_index_to)") ;; TODO Change to most available peer if necessary
  if not transfer-success [
    output-print(word "Blockchain transfer successful :" transfer-success)
  ]
end

to remove_attacker_influence
  ask peers [
    if not is-down [ stop ] 
    py:set "p_id" [peer-id] of self 
    py:run "pyagent.remove_attacker_influence(run_no, p_id)"
    set is-down False
    set shape "a_peer"
  ]
end

to-report get_proposer
  py:set "prev_proposer_id" current-block-proposer-id
  let candidate ""
  while [candidate = ""] [
    set candidate (py:runresult "pyagent.get_proposer(run_no, prev_proposer_id)")
    ask peers with [peer-id = candidate] [
      if is-down [ set candidate "" ]
    ]
  ]
  py:set "curr_proposer_id" candidate
  py:run "pyagent.complete_proposer_transfer(run_no, prev_proposer_id, curr_proposer_id)"
  output-print(word "candidate " candidate)
  report candidate  
end

to attack_agent
  py:set "p_id" [peer-id] of self 
  set is-down (py:runresult "pyagent.attack_agent(run_no, p_id)")
  if not is-down [ stop ]
  set shape "a_victim"
  ;; ask my-peer-cons [ set color red ] ;; TONOTE: Not necessary since incoming would still work (and be wasted cuz agent is down)
end



