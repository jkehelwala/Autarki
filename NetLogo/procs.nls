
to setup
  clear-all
  py:setup py:python
  py:run "import autarki_agent as pyagent"
  set-run
  set-constants
  setup-peers
  ;; setup_gossip_transactions ;; (NOTE: Used for gossip transaction propogation over direct transmission)
  reset-ticks ;; start the clock
  set-plots
end

to set-plots
  set-plot-x-range -1 No-of-Peers
  set-plot-y-range 0 100
end

to set-run
  py:set "run_no" behaviorspace-run-number
  py:set "run_name" behaviorspace-experiment-name
  py:set "total_peers" No-of-Peers
  py:set "required_votes" Votes-Required ;; Percentage Conversion done inside python
  py:set "timeout_in_seconds" Block-Timeout
  py:set "learning_strategy" Learning-Methodology
  py:set "is_cost_heterogeneous" Heterogeneous-Cost
  py:set "benefit_per_unit_of_cost" Benefit-Per-Unit-Of-Cost
  py:set "minimum_attack_probability" Min-Attack-Probability
  py:set "desc_data" "" ;; Misc Data
  py:run "pyagent.init_run(run_no, run_name, total_peers, required_votes, learning_strategy, is_cost_heterogeneous, benefit_per_unit_of_cost, minimum_attack_probability, desc_data)"
end

to set-constants
  set-default-shape peers "a_peer"
  ;; Constant setup
  set subdue-color 2
  set current-round 0
  ;; Timing setup (TODO: Move to UI if necessary)
  set new-transaction-generation-time 10 ;; TODO Increase if transaction propagation is used
  set peer-breathe-time 2
end

to go
  schedule_transaction_propagation_temp ;; TODO change for realistic simulation
  initiate-round
  time:go-until Duration;; (TODO: substitute ticks with number of rounds when termination is deterministic)
  ;; py:run "pyagent.log_agent_chains(run_no)"
  ;; ask peers [ console-log(list who transactions) ] ;; TODO
end

to-report current-round-no
  report current-round
end

to-report current-block-no
  report current-block
end

to-report overall-block
  report ( (current-round - 1)* No-of-Peers ) + current-block
end

to-report attack_tolerance_data
  let no-of-attackers-tolerable (py:runresult "pyagent.get_no_of_attackers_tolerable(run_no)")
  report (word count peers with [is-down] "/" no-of-attackers-tolerable)
end

to setup-peers
  ;; Creating Servers
  create-servers 1 [
    set color blue
    set shape "a_server"
    setxy -15 0
  ]
  create-attackers 1 [
    set color orange
    set shape "monster"
    setxy 15 0
  ]
  set bserver one-of servers
  set battacker one-of attackers
  ;; Creating Peers
  create-peers No-of-Peers [
    ;; set color turquoise
    setxy random-pxcor random-pycor
    set transactions "{}"
    set is-down False
    ;; set-up-peer-link-data (Refer retired.nls)
    py:set "x" who ;; TONOTE: This is for record keeping/signature. Peers will not be addressed through this.
    set peer-id (py:runresult "pyagent.create_peer(run_no, x)")
  ]
  ask bserver [
    ;; show max-one-of peers [distance myself]
    create-server-cons-with other peers [
      set color blue - subdue-color
      ;; set delay [con-strength] of other-end
    ]
    ;; ask my-out-server-cons []
  ]
  ask battacker [
    create-attacker-cons-to other peers [
      ;; set delay [con-strength] of other-end
      set color orange - subdue-color
    ]
  ]
  ask peers [ set delay-from-server ceiling(distance bserver) ]
  verify-timeout
  ;; set-up-peer-links (Refer retired.nls)
  py:set "peers_list" [peer-id] of peers
  py:run "pyagent.set_peer_network_variables(run_no, peers_list)"
end

to verify-timeout
  ask max-one-of peers [delay-from-server] [
    let min-timeout-requirement (2 * [delay-from-server] of self) 
    if min-timeout-requirement > Block-Timeout [
      console-log(word "WARNING: Timeout insufficient. Minimum " min-timeout-requirement " required")
      ;; set Block-Timeout min-timeout-requirement
      ;; console-log(word "WARNING: Timeout updated to " min-timeout-requirement)
    ]
  ]
end

to initiate-round
  set current-round (current-round + 1)
  py:set "current_round" current-round
  set current-block 0
  remove-attacker-influence
  ask peers [carefully [ poll-for-missing-transactions-and-blocks ][console-log("ERROR")] ]
  py:run "pyagent.start_round(run_no, current_round)"
  ask battacker [ set blocks-to-attack (py:runresult "pyagent.get_blocks_to_attack(run_no, current_round)")  ]
  schedule-block 10 ;; Start after at least 10 transactions
end

to schedule-block [tail] ;; Schedule block after at least tail transactions
    let new-time (ticks + (new-transaction-generation-time * tail))
    time:schedule-event "observer" [ [] -> initiate-block ] new-time  ;; Start after at least `tail` transactions
end

to plot-vote-precentage
  let obtained-votes-no (py:runresult "pyagent.get_no_of_votes(run_no)")
  let obtained-vote-precentage ( ( obtained-votes-no / No-of-Peers ) * 100 )
  plotxy overall-block obtained-vote-precentage
end

to initiate-block
  ask bserver [
    console-log(word "Finished: Round: " current-round " Block: " current-block " Attack Tolerance: " attack_tolerance_data)
    update-plots
    plot-vote-precentage
  ]
  if (current-block + 1) > No-of-Peers [
    initiate-round
    stop
  ]
  set current-block (current-block + 1)
  console-log(word "Started: Round: " current-round " Block: " current-block)
  remove-attacker-influence
  if member? current-block [blocks-to-attack] of battacker [
    ask battacker [
      ask attacker-con-neighbors [ attack-agent ]
    ]
  ]
  ask peers [carefully [ poll-for-missing-transactions-and-blocks ][console-log("ERROR")] ]
  console-log("Polling completed")
  let current-block-start-time ticks
  py:set "curr_time" current-block-start-time
  ask bserver [
    set server-block (py:runresult "pyagent.get_new_block(run_no, curr_time)")
    console-log(server-block)
    if server-block = "{}" or server-block = "" [
      console-log(word "Empty Block: Round: " current-round " Block: " current-block)
      schedule-block 20
      stop
    ]
    let timeout-point (current-block-start-time + Block-Timeout)
    ask out-server-con-neighbors [
      if not is-down [
        time:schedule-event self [ [] -> vote-for-block timeout-point ] (current-block-start-time + (delay-from-server))
      ]
    ]
    time:schedule-event self [ [] -> evaluate-votes ] timeout-point
  ]
end

to vote-for-block [timeout]
  if is-down [stop]  ;; TODO map path back to server and vote only if necessary
  if ticks  >= timeout [ stop ]
  py:set "proposed_block" server-block
  py:set "voting_peer" [peer-id] of self
  let verify (py:runresult "pyagent.authenticate_and_vote(run_no, voting_peer, proposed_block)")
  if verify [
    py:run "pyagent.notify_server(run_no, voting_peer)"
  ]
end

to evaluate-votes
  let block-voted-in (py:runresult "pyagent.check_block_status(run_no)")
  if block-voted-in [
    let updated-block (py:runresult "pyagent.get_voted_block_json(run_no)")
    let tmp-ticks ticks
    ask out-server-con-neighbors [
      if not is-down [
        time:schedule-event self [ [] -> push-voted-block-to-peer updated-block ] (tmp-ticks + (delay-from-server)) 
      ]
    ]
  ]
  schedule-block 20
end

to push-voted-block-to-peer [updated-block]
  py:set "added_block" updated-block
  py:set "peer_id" [peer-id] of self
  let pushed (py:runresult "pyagent.push_voted_block_to_peer(run_no, peer_id, added_block)")
end

to poll-for-missing-transactions-and-blocks
  if is-down [stop]
  py:set "p_id" [peer-id] of self
  py:run "pyagent.polling_actions(run_no, p_id)"
end

to remove-attacker-influence
  ask peers [
    if not is-down [ stop ]
    py:set "p_id" [peer-id] of self
    py:run "pyagent.remove_attacker_influence(run_no, p_id)"
    set is-down False
    set shape "a_peer"
  ]
end


to attack-agent
  py:set "p_id" [peer-id] of self
  set is-down (py:runresult "pyagent.attack_agent(run_no, p_id)")
  if not is-down [ stop ]
  set shape "a_victim"
  ;; ask my-peer-cons [ set color red ] ;; TONOTE: Not necessary since incoming would still work (and be wasted cuz agent is down)
end
