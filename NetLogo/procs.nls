
to setup
  clear-all
  set last-proposed-block ""
  set overall-block 0
  set_constants
  setup_peers
  reset-ticks ;; start the clock
  set-plots
  initiate_round
end

to set-plots
  set-plot-x-range -1 No-of-Peers
  set-plot-y-range 0 100
end


to set_constants
  set no-of-votes-required ceiling( No-of-Peers  * ( Votes-Required / 100 ) )
  set-default-shape peers "a_peer"
  ;; Constant setup
  set subdue-color 4
  set current-round 0
  set current-block-proposer-id ""
  ;; Timing setup (TODO: Move to UI if necessary)
  set peer-breathe-time 2
end

to scheduled-events
  if waiting-for-init [stop]
  if ticks mod Block-Timeout = 0 [ initiate_block ]
  ask peers [
    if ticks mod con-strength = 0 [ push-peer-block ]
  ]
end

to go
  if current-round > Rounds [ stop ] ;; Stopping forever button
  tick
  scheduled-events
end

to-report current-round-no
  report current-round
end

to-report current-block-no
  report current-block
end

to-report attack_tolerance_data ;; Possibility of protection being enough for the block to be voted in 
  ;; report (No-of-Peers - no-of-votes-required ) >= count peers with [is-down]
  report (word count peers with [is-down] "/" (No-of-Peers - no-of-votes-required ) )
end

to setup_peers
  ;; Creating Servers
  create-servers 1 [
    set color blue
    set shape "a_server"
    setxy -15 0
  ]
  create-attackers 1 [
    set color orange
    set shape "monster"
    setxy 15 0
  ]
  set bserver one-of servers
  set battacker one-of attackers
  
  let benefit-list benefit-assignment
  ;; Creating Peers
  create-peers No-of-Peers [
    ;; set color turquoise
    setxy random-pxcor random-pycor
    set peer-id (word "p_" who)
    set benefit-puoc first benefit-list
    set benefit-list remove-item 0 benefit-list ;; pop benefit
    set block ""
    set block-voters []
    set chain []
    set roundchain []
    set is-protected False
    set is-down False
    set con-strength Min-Con-Strength +  random (Max-Con-Strength - Min-Con-Strength)
    set allowed-link-no Min-Peer-Cons + random (Max-Peer-Cons - Min-Peer-Cons)
    
    ;; Reputation Maximization
    set peer-reputation 0
    set valid-probability False
    set prev-f 0
    
    
  ]
  ask bserver [
    create-server-cons-to other peers [
      set color blue - subdue-color
      set delay [con-strength] of other-end
    ]
    ;; ask my-out-server-cons []
  ]
  ask battacker [
    create-attacker-cons-to other peers [
      set delay [con-strength] of other-end
      set color orange - subdue-color
    ]
  ]
  ask peers [
    let available-links [allowed-link-no] of self - (count my-peer-cons ) ;; leftover links than the default server/attacker connections
    if available-links > 0 [
      create-peer-cons-with n-of available-links other peers
    ]
    ask peer-cons [
      set color turquoise
      set delay min(list [con-strength] of end1 [con-strength] of end2)
      ;; set thickness delay /(last const-con-strength * 10) ;; TODO: Uncomment for visual confirmation
    ]
  ]
end

to initiate_round
  set waiting-for-init true
  set current-round (current-round + 1)
  if current-round > Rounds [
    console-log("Round number reached. Simulation will stop soon.")
    stop
  ]
  set current-block 0
  remove_attacker_influence
  if current-round > 1 [
    synchronize-current-round-chain
    if (Learning-Methodology = "Reputation Maximization") [ ask peers [rm-set-reputation]  ]
  ]
  ask peers [ set chain [] ]
  ask peers [ set-peer-protection-decision ]  
  ask battacker [ set-list-of-blocks-to-attack  ]
  set waiting-for-init false
end

to plot-vote-precentage
  let obtained-votes-no count peers with [not empty? chain and first last chain = last-proposed-block] ;; first element (block string) of last item in chain
  plotxy overall-block ( ( obtained-votes-no / No-of-Peers ) * 100 )
end

to initiate_block
  if overall-block > 0 [  
    ask peers [ finalize-proposed-block ]
    console-log(word "Finished: Round: " current-round " Block: " current-block " Overall Block: " overall-block " Attack Tolerance: " attack_tolerance_data)
    update-plots
    plot-vote-precentage 
  ]
  if (current-block + 1) > No-of-Peers [
    initiate_round
    stop
  ]
  set current-block (current-block + 1)
  set overall-block (overall-block + 1)
  ;; console-log(word "Started: Round: " current-round " Block: " current-block " Overall Block: " overall-block)
  remove_attacker_influence
  if member? current-block [blocks-to-attack] of battacker [
    ask battacker [
      ask attacker-con-neighbors [ attack_agent ]
    ]
  ]
  
  ;; Confirm at least one proposer is available (Limitation)
  let valid-proposers count peers with  [not is-down and peer-id != current-block-proposer-id ]
  if valid-proposers = 0 [
    ask one-of peers with  [peer-id != current-block-proposer-id ] [ remove_attacker_influence_for_peer ]
  ]
  
  ask one-of peers with  [not is-down and peer-id != current-block-proposer-id ] [ ;; ask new proposer
    set current-block-proposer-id peer-id
    set current-block-start-time ticks
    set block (word "b_" overall-block "_" current-block-proposer-id)
    set last-proposed-block block
    add-block-vote current-block-proposer-id
    push-peer-block
  ]
end

to receive-block [proposed-block voter-list]
  if is-down [ stop ]
  if empty? proposed-block or empty? voter-list [ stop ]
  if empty? block [
    set block proposed-block
  ]
  set block-voters sentence block-voters voter-list
  set block-voters remove-duplicates block-voters
  if not empty? block and proposed-block = block [
    add-block-vote peer-id
  ]
  ;; console-log(word "Received " block " " voter-list)
end


to push-peer-block ;; turtle-method
  if empty? block or is-down [ stop ]
  let proposed-block block
  let voter-list block-voters
  ask out-peer-con-neighbors [
    receive-block proposed-block voter-list
  ]
end

to finalize-proposed-block ;; turtle-method
  if not is-down [ 
    if length block-voters > no-of-votes-required [
      set chain lput (list block block-voters) chain 
    ]
  ]
  set block ""
  set block-voters []
end

to remove_attacker_influence
  ask peers [ remove_attacker_influence_for_peer ]
end

to remove_attacker_influence_for_peer
  if not is-down [ stop ]
  set is-down False
  set shape "a_peer"
end

to synchronize-current-round-chain
  ask peers [
    let parent-subchain-keys map first chain
    let list-of-votes map last chain
    ask other peers [
      let peer-subchain-keys map first chain
      let missing-keys filter [ i -> not member? i parent-subchain-keys ] peer-subchain-keys
      ifelse (length missing-keys + length list-of-votes) > No-of-Peers [ console-log(" Filtering error. Skipping synchronization.") ]
      [ ;; else
        foreach missing-keys [ x -> 
          let missing-item item (position x map first chain) chain
          set list-of-votes lput (last missing-item) list-of-votes
        ]
      ]
    ]
    set roundchain lput list-of-votes roundchain
  ]
end


to attack_agent
  if not is-protected [
    set is-down True
    set shape "a_victim"
  ] 
end

to add-block-vote [ voter ] ;; turtle-method
  if not member? voter block-voters [
     set block-voters lput voter block-voters
  ]
end

to set-list-of-blocks-to-attack ;; attacker-method
  let attack-prob ( Min-Attack-Probability + random-float (0.99 - Min-Attack-Probability) )
  let no-of-blocks-to-attack ceiling(attack-prob * No-of-Peers) ;; or Floor?
  set blocks-to-attack []
  while [length blocks-to-attack < no-of-blocks-to-attack]
  [ 
    let b-no 1 + random No-of-Peers
    if not member? b-no blocks-to-attack [
     set blocks-to-attack lput b-no blocks-to-attack
    ]
  ]
end

to set-peer-protection-decision ;; peer method
  set is-protected get-protection
end


to-report benefit-assignment
  if not Heterogeneous-Cost [ report n-values No-of-Peers [ Benefit-Per-Unit-Of-Cost ] ]  ;; Homogeneous cost
  report map [ i -> Benefit-Per-Unit-Of-Cost / i ] n-values No-of-Peers [ random-normal 1.0 Cost-Std-Dev ]  ;; Heterogenous cost
end

